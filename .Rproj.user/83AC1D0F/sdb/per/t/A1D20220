{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Multiview\"\nauthor: \"OEB\"\ndate: \"May 16, 2017\"\noutput:\n  html_document:\n    code_folding: hide\n    df_print: paged\n    number_sections: yes\n    theme: sandstone\n    toc: yes\n    toc_depth: 3\n    toc_float:\n      collapsed: no\n      smooth_scroll: no\nruntime: shiny\nparams:\n  data: !r ISLR::Auto\n  data_input: TRUE\n---\n\n<style>\n  .main-container {\n    max-width: 1920px !important;\n  }\n</style>\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = F, warning = F, message = F, eval = T)\n```\n\n```{r libraries, echo=FALSE, message=F, warning=FALSE}\n\nlibrary(knitr)\nlibrary(ISLR)\nlibrary(tabplot)\nlibrary(tidyverse)\nlibrary(tabplot)\nlibrary(randomForest)\nlibrary(stringr)\nlibrary(GGally)\nlibrary(forcats)\nlibrary(caret)\nlibrary(ggcorrplot)\nlibrary(Amelia)\nlibrary(e1071)\nrequire(shiny)\n\n# define better color palette\nqual_col_pals  = RColorBrewer::brewer.pal.info[RColorBrewer::brewer.pal.info$category == 'qual',]\ncolor_pallette = unlist(mapply(RColorBrewer::brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))\n\n\nsource( stringr::str_c(getwd(),'/mod_load_data v03.R') )\n\nsource( stringr::str_c(getwd(),'/mod_summary v02.R') )\n\nsource( stringr::str_c(getwd(), '/mod_clean_data v05.R') )\n\nsource( stringr::str_c(getwd(), '/mod_vis_groups_v03.R') )\n\nsource( stringr::str_c(getwd(), '/mod_tree_v04.R') )\n\nsource( stringr::str_c(getwd(), '/mod_save_v01.R') )\n\n\n```\n\n```{r reactive_values}\n\n# this creates an object like input, that can store multiple\n# reactive values, this object stores values which we will use\n# to signal if certain calculations or processes are finished.\n\nstatus = reactiveValues( data = NULL)\n\nstatus$load     = 'No Data loaded. Select Data and Press Load button!'\nstatus$summary  = NULL\nstatus$clean    = NULL\nstatus$ana      = NULL\nstatus$pca      = NULL\nstatus$imp      = NULL\nstatus$corr     = NULL\nstatus$group_stat = NULL\nstatus$tree     = NULL\n\n\nobserveEvent({\n  \n  input$but_load\n  input$but_clean\n\n  }\n  ,{\n  status$pca      = NULL\n  status$imp      = NULL\n  status$corr     = NULL\n  status$group_stat = NULL\n  status$tree     = NULL\n})\n\n\n# renderText(status$load)\n# renderText(status$summary)\n# renderText(status$clean)\n# renderText(status$ana)\n# renderText(status$pca)\n# renderText(status$imp)\n# renderText(status$corr)\n# renderText(status$group_stat)\n# renderText(status$tree)\n\n\n```\n\n\n#Data\n\n## Load Data\n\n```{r load, eval = params$data_input == TRUE}\n\n# load two ui_elements and the save_plot() function\n# and the rea_load reactive element which returns \n# the data\n\nmod_load_data_ui()\n\nrea_load = mod_load_rea(input, status)\n\nrenderText( status$load )\n\n```\n\n```{r external_load, eval= params$data_input == FALSE}\n\ndata = params$data\n\nrea_load = reactive({\n  \n  data\n  \n})\n\n\n```\n\n\n\n## Clean Data\n\n```{r clean}\n\nmod_clean_ui(rea_load)\n\nrenderText( status$clean )\n\nrea_clean = mod_clean_rea(input, status, rea_load)\n\n```\n\n## Summary\n\n```{r summary , eval = T}\n\nmod_summary_ui(rea_clean)\n\n```\n\n## Start Analysis\n\n```{r ana}\n\nmod_ana_ui(rea_clean, select_grouping_var = T)\n\nrenderText( status$ana )\n\nrea_ana   = mod_ana_rea(input, status, rea_clean)\n\n```\n\n\n# Analysis\n\n## Groupings\n\n### Group Vis\n\n\n\n```{r group_vis, eval = T}\n\n\n\nmod_vis_groups_ui(rea_ana, input$default_group)\n\nmod_vis_groups_render_no_obs(input, rea_ana, color_pallette = color_pallette)\n\n\nmod_vis_groups_render_numericals(input, rea_ana, boxcox = T, color_pallette = color_pallette)\n\nmod_vis_groups_render_categoricals(input, rea_ana, color_pallette = color_pallette)\n\n\n\n```\n\n\n### Group Statistics\n\n```{r stats_ui, eval = T}\n\nrenderUI({\n  \n  d_clean = rea_ana()\n  categoricals = d_clean$categoricals\n  \n  inputPanel(\n  \n  selectInput(\"group_stats\"\n              , label = \"select grouping variable\"\n              , choices = categoricals\n              , selected = input$default_group )\n  )\n  \n})\n\nf_bring_to_pos_range = function(x){\n  \n\n  if( min(x)< 0) x = x + abs(min(x))\n  \n\n  return(x)\n}\n\nf_diff_of_means_medians = function(df, group, variable){\n  \n\n  data = df %>%\n    select( group = one_of(group), variable = one_of(variable) )%>%\n    mutate ( variable = f_bring_to_pos_range(variable) ) %>%\n    group_by( group ) %>%\n    summarise( means     = mean(variable,   na.rm = T)\n               , medians = median(variable, na.rm = T) ) %>%\n    ungroup() %>%\n    summarise( diff_of_means        = max(means) - min(means)\n               , diff_of_means_perc = ( ( max(means) - min(means) ) /max(means) ) *100\n               , diff_of_medians      = max(medians) - min(medians)\n               , diff_of_medians_perc = ( ( max(medians) - min(medians) ) /max(means) ) *100    )\n  \n\n  return(data)\n}\n\nf_max_diff_of_freq = function(df, var1, var2){\n  \n  t = table( df[[var1]], df[[var2]] ) %>%\n    as_tibble() %>%\n    group_by( Var1 ) %>% \n    mutate ( diff_var1          = ( max(n)-min(n) ) \n               , diff_var1_perc = ( ( max(n)-min(n))/ max(n) *100) \n             ) %>%\n    group_by( Var2 ) %>%\n    mutate ( diff_var2          = ( max(n)-min(n) ) \n               , diff_var2_perc = ( ( max(n)-min(n))/ max(n) *100) \n              ) %>%\n    ungroup()%>%\n    summarise( max_diff_freq          = max( c(diff_var1, diff_var2) )\n               , max_diff_freq_perc  = max( c(diff_var1_perc, diff_var2_perc) ) \n    )\n}\n\nf_anova_stats = function(df, group, variables) {\n  # returns a dataframe with anova stats\n  # df        : dataframe\n  # group     : grouping variable as character vector, must indicate factor variable\n  # variables : numerical variables to be analyzed as character vector, must indicate numerical variable\n  \n  data = df\n  \n  formula = stringr::str_c('value~',group) %>%\n    as.formula()\n  \n  df_anova = data %>%\n    as_tibble() %>%\n    select( one_of( c(group, variables) ) ) %>%\n    gather(key = 'variable', value = 'value', one_of( variables ) ) %>%\n    group_by( variable ) %>%\n    nest( one_of(group), value) %>%\n    mutate( model_anova     = purrr::map( data, ~aov( formula, data = .)) \n            , summary_anova = purrr::map( model_anova, summary)\n            , summary_anova = purrr::map( summary_anova\n                                          , function(x) x[[1]])\n            , anova_pval    = purrr::map(summary_anova, 'Pr(>F)')\n            , anova_pval    = purrr::map_dbl(anova_pval\n                                             , function(x) x[1])\n            , model_kruskal = purrr::map( data, ~kruskal.test(formula, data = .) )\n            , kruskal_pval  = purrr::map_dbl(model_kruskal, 'p.value')\n            , model_shapiro = purrr::map(data\n                                      , function(x) shapiro.test(sample(x$value, 5000, replace = T) ) )\n            , shapiro_stat  = purrr::map_dbl(model_shapiro,'statistic')\n            , shapiro_pval  = purrr::map_dbl(model_shapiro,'p.value') \n            , diff_df       = purrr::map( data, f_diff_of_means_medians, group = group, variable = 'value') ) %>%\n    unnest(diff_df) %>%\n    select(variable\n           , shapiro_stat\n           , shapiro_pval\n           , anova_pval\n           , kruskal_pval\n           , diff_of_means\n           , diff_of_means_perc\n           , diff_of_medians\n           , diff_of_medians_perc\n           )\n  \n  return(df_anova)\n}\n\nf_chi_square = function(df, group, variables) {\n  # returns a dataframe with anova stats\n  # df        : dataframe\n  # group     : grouping variable as character vector, must indicate factor variable\n  # variables : numerical variables to be analyzed as character vector, must indicate factor variable\n  \n  data = df\n  \n  variables = variables[!variables == group]\n  \n  if(purrr::is_empty(variables)) return()\n\n  df_chi = data %>%\n    as_tibble() %>%\n    select( one_of( c(group, variables) ) ) %>%\n    gather(key = 'variable', value = 'value', one_of( variables  ) ) %>%\n    group_by( variable ) %>%\n    nest( one_of( group ), value) %>%\n    mutate(  model_chi = purrr::map( data, ~chisq.test(x = .[[group]]\n                                                       , y = .[['value']]\n                                                       ) )\n            ,chi_pval  = purrr::map_dbl(model_chi, 'p.value')\n            ,diff_df   = purrr::map(data, f_max_diff_of_freq, group, 'value')  ) %>%\n    unnest(diff_df) %>%\n    select(variable, chi_pval, max_diff_freq, max_diff_freq_perc)\n    \n  return(df_chi)\n}\n\nrea_group_stats = reactive({\n  \n  validate(need(status$ana, 'Waiting for BoxCox transformation') )\n  \n  withProgress(message = 'Calculating group statistics'\n               ,{\n    \n    d_clean    = rea_ana()\n    data       = d_clean$data\n    boxcox     = d_clean$boxcox\n    numericals = d_clean$numericals\n    categoricals = d_clean$categoricals\n  \n    if(! is_empty(numericals)) {\n      \n  \n      df_num    = f_anova_stats(df = data\n                               ,group = input$group_stats\n                               ,variables = numericals\n                               )\n      \n      df_boxcox = f_anova_stats(df = data\n                                ,group = input$group_stats\n                                ,variables = boxcox\n                                )\n      \n      sig_num = df_num %>%\n        mutate( p_val = ifelse(shapiro_stat >= 0.9\n                               , anova_pval\n                               , kruskal_pval) \n                ) %>%\n        filter(p_val <= 0.001) %>%\n        .[['variable']]\n      \n      sig_boxcox = df_boxcox %>%\n        mutate( p_val = ifelse(shapiro_stat >= 0.9\n                               , anova_pval\n                               , kruskal_pval) \n                ) %>%\n        filter(p_val <= 0.001) %>%\n        .[['variable']]\n      \n  \n    } else {\n      \n      df_num     = NULL\n      df_boxcox  = NULL\n      sig_num    = NULL\n      sig_boxcox = NULL\n      \n    }\n    \n    \n    \n    # only works with minimum two categoricals vars\n    if( length(categoricals) >= 2 ){\n      \n      df_chi    = f_chi_square(df = data\n                                ,group = input$group_stats\n                                ,variables = categoricals\n                               )\n      \n      sig_chi = df_chi %>%\n        filter(chi_pval <= 0.001) %>%\n        .[['variable']]\n      \n  \n    } else{\n      \n      df_chi  = NULL\n      sig_chi = NULL\n    }\n  \n  })\n  \n  status$group_stat = T\n  \n  return( list( df = list(df_num     = df_num\n                          ,df_boxcox = df_boxcox\n                          ,df_chi    = df_chi\n                          )\n                , sig = list(sig_num     = sig_num\n                           ,sig_boxcox = sig_boxcox\n                           ,sig_chi    = sig_chi\n                           ) \n                ) \n          )\n  \n})\n\n```\n\n\n### Numericals (ANOVA)\n\n```{r anova_num, eval = T}\n\n\nrender_table_num_group_stat = function( boxcox = F, rea_group_stats) {\n  \n\n  \n  DT::renderDataTable(\n   extensions = 'Buttons'\n   , options = list( dom       = 'Bftrip'\n                    , buttons = c('copy', 'excel')\n                    , pageLength = 1\n                    )\n  ,{\n  \n    withProgress(message = 'Rendering Group Statistics Table'\n                 ,{\n    \n      group = input$group_stats\n      \n      if( boxcox == F ){ \n        \n        df = rea_group_stats()$df$df_num\n        \n      }else{\n        \n        df = rea_group_stats()$df$df_boxcox\n        \n      }\n      \n        df = DT::datatable(df\n                           , extensions = 'Buttons'\n                           , options    = list( dom       = 'Bftrip'\n                                                , buttons = c('copy', 'excel')\n                                                )\n                       ) %>%\n        DT::formatStyle('shapiro_stat'\n                        , color = DT::styleInterval(0.9, c('red','green') )\n                        ) %>%\n        DT::formatStyle(3:5\n                        , color = DT::styleInterval(0.01, c('green','red') )\n                        ) %>%\n        DT::formatRound(2:5, 6) %>%\n        DT::formatRound(c(6,8), 3) %>%\n        DT::formatRound(c(7,9), 2)\n  \n    })\n  })\n\n}\n\nrender_table_num_group_stat( boxcox = F, rea_group_stats )\n\n```\n\n### Numericals boxcox (ANOVA)\n\n```{r anova_num_boxcox, eval = T}\n\nrender_table_num_group_stat( boxcox = T, rea_group_stats )\n\n```\n\n### Categoricals (Chi-Square)\n\n```{r chi_square, eval = T}\n\n\nDT::renderDataTable({\n  \n  withProgress(message = 'Rendering Group Statistics Table'\n               ,{\n  \n    d_clean    = rea_ana()\n    data       = d_clean$data\n    boxcox     = d_clean$boxcox\n    numericals = d_clean$numericals\n    categoricals = d_clean$categoricals\n    \n    \n    group = input$group_stats\n    \n    df = rea_group_stats()$df$df_chi \n    \n    df = DT::datatable(df\n                       , extensions = 'Buttons'\n                       , options    = list( dom = 'Bftrip'\n                                            , buttons = c('copy', 'excel')\n                                            )\n                       ) %>%\n      DT::formatStyle('chi_pval'\n                      , color = DT::styleInterval(0.01, c('green','red') )\n                      ) %>%\n      DT::formatRound( 2, 6)   %>%\n      DT::formatRound( 4, 2)\n  \n  })\n  \n  return(df)\n  \n})\n\n\n```\n\n\n\n## Predictive Capacity\n\n\n```{r importance, eval = T }\n\nrenderUI({\n  \n  # validate( need(status$group_stat\n  #                , message = 'Waiting for Group Stats') )\n  \n  d_clean = rea_ana()\n  categoricals = d_clean$categoricals\n  numericals   = d_clean$numericals\n\n  inputPanel(\n    \n    selectInput(\"group_imp\"\n                , label = \"select predicted variable\"\n                , choices = c(categoricals, numericals)\n                , selected = input$default_group)\n    \n  )\n\n})\n\nrea_imp = reactive({\n  \n  #status$imp = NULL\n  \n  validate(\n    need(status$group_stat, 'Waiting for Group Stats')\n  )\n  \n  withProgress(message = 'Calculating predictive capacity'\n               ,{\n  \n    d_clean = rea_ana()\n    data = d_clean$data\n    all_variables = d_clean$all_variables\n    \n    form = as.formula( stringr::str_c(input$group_imp,'~.') )\n    \n    m = randomForest::randomForest(form, data[, all_variables] )\n    \n    imp = tibble( mean_decrease_gini = m$importance[,1]\n                  ,variable = names(m$importance[,1])\n                  ,group = input$group_imp) %>%\n      arrange(desc(mean_decrease_gini))\n  \n  })\n  \n  status$imp = T \n  \n  return(imp)\n  \n})\n\nrenderPlot({\n  \n  \n  validate(\n    need(status$group_stat, 'Waiting for Group Stats')\n  )\n  \n  \n  imp = rea_imp()\n  \n  p = ggplot(imp) +\n    geom_bar(aes(x = fct_reorder(variable\n                             , mean_decrease_gini) \n                , y = mean_decrease_gini\n                , fill = fct_reorder(variable\n                                 , mean_decrease_gini\n                                 , .desc = T)\n                )\n            , stat = 'identity'\n            , show.legend = F) +\n        coord_flip() +\n        labs( x = 'Variable'\n              , y = 'Predictive capacity (Mean decrease in Gini)')\n  \n  \n  name = stringr::str_c( input$sql_or_lib,'_predictive_capacity_', imp[[1,'group']] )\n  \n\n  save_plot(plot = p\n            , path = input$path\n            , name = name\n            , yes = input$save\n            , excel = input$save_excel\n            )\n  \n  return(p)\n  \n})\n\n\n```\n\n## Decision Tree\n\n```{r}\n\n\nmod_tree_UI(input, status, rea_ana )\n\nrea_tree = mod_tree_rea(input, status, rea_ana)\n\nmod_tree_plot(input, status, rea_tree)\n\nmod_tree_UI_plot()\n\nmod_tree_prune_plot(input, rea_tree, rea_ana)\n\n```\n\n\n## Principle Component Analysis\n\n### Plot Principle Components\n\n\n```{r pca, eval = T  }\nrea_pca = reactive({\n  \n  \n  validate(\n    need(status$group_stat, 'Waiting for Group Stats')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$tree, 'Waiting for Decision Tree Data')\n  )\n  \n  #status$pca = NULL\n  \n  withProgress(message = 'Calculating Principle Components'\n               , {\n  \n    d_clean       = rea_ana()\n    data          = d_clean$data\n    boxcox        = d_clean$boxcox\n    categoricals  = d_clean$categoricals\n    all_variables = d_clean$all_variables\n    numericals    = d_clean$numericals\n    \n    if(is_empty(numericals) | is_empty(boxcox)) return()\n    \n    if(input$boxcox_pca == T) {\n      \n      vars = boxcox\n      \n    }\n    else{\n      \n      vars = numericals\n    }\n    \n    pca = prcomp(x = select(data, one_of(vars) )\n                 , scale. = input$scale_pca\n                 , center = input$center_pca)\n    \n    pca$cos2 = pca$rotation^2\n    \n    pca$contrib = lmap( as_tibble(pca$cos2 ), function(y) y/ sum(y) *100 )\n    row.names(pca$contrib) = row.names(pca$cos2)\n    \n    pca$vae = as_tibble (t( pca$sdev / sum(pca$sdev) *100 ) )\n    colnames(pca$vae) = colnames(pca$contrib)\n    \n    pca$contrib_abs_perc = t( t( apply( pca$contrib/100, 1, function(x,y) x*pca$vae ) ) )\n    pca$contrib_abs_perc = unnest( as.data.frame( pca$contrib_abs_perc) )\n    row.names(pca$contrib_abs_perc) = row.names(pca$contrib)\n    \n    pca$contrib_abs_perc = as.data.frame( t(pca$contrib_abs_perc) )\n    pca$contrib_abs_perc$var = row.names(pca$contrib_abs_perc)\n    \n    pca$contrib_abs_perc = pca$contrib_abs_perc %>%\n      gather(key = 'key', value = 'value', everything(), -var) \n    \n    #group variables with less than 2.5% contribution\n    pca$contrib_abs_perc_reduced = pca$contrib_abs_perc  %>%\n      mutate(key = ifelse(value < 2.5\n                          , ' sum contrib < 2.5%'\n                          , key)) %>%\n      group_by( var, key) %>%\n      summarise( value = sum(value) )\n    \n  \n    # filter principle components that explain less than\n    # 2.5% of the variance\n    \n    pca$x                        = pca$x[, pca$vae > 2.5]\n    \n    pca$contrib_abs_perc         = pca$contrib_abs_perc %>%\n      filter(var %in% colnames(pca$x))\n    \n    pca$contrib_abs_perc_reduced = pca$contrib_abs_perc_reduced %>%\n      filter(var %in% colnames(pca$x))\n    \n    data = data %>%\n      cbind(pca$x)\n\n  })\n  \n  status$pca = T\n  \n  return(list(data = data, pca = pca) )\n\n})\n\nrenderUI({\n\n  inputPanel(\n    \n\n     checkboxInput('center_pca', label = 'center', value = T)  \n    \n    , checkboxInput('scale_pca', label = 'scale', value = T)  \n    \n    , checkboxInput('boxcox_pca', label = 'boxcox', value = T)  \n    \n    \n    \n  )\n  \n})\n\n\n\n```\n\n### Plot Principle Components\n\n```{r prin_comp}\n\n\n# rotation plot\nrenderPlot({\n  \n  validate(\n    need(status$group_stat, 'Waiting for Group Stats')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$tree, 'Waiting for Decision Tree Data')\n  )\n  \n  data = rea_pca()$data\n  pca  = rea_pca()$pca\n  \n  group  = input$group_pca\n  x_axis = input$x_axis_pca\n  y_axis = input$y_axis_pca\n  \n  \n  if(input$group_pca == 'None') group = NULL \n  \n  p = ggplot(data) +\n    geom_point( aes_string(x = x_axis, y = y_axis, color = group)\n                ,alpha=0.4 ) +\n    labs(title = 'plot1')\n\n  \n  name = stringr::str_c( input$sql_or_lib,'_principle_component_')%>%\n    stringr::str_c( input$group_pca ) %>%\n    stringr::str_c('_boxcox', input$boxcox_pca) %>% \n    stringr::str_c('_scale',  input$scale_pca) %>% \n    stringr::str_c('_center', input$center_pca) \n\n  save_plot(plot = p\n        , path = input$path\n        , name = name\n        , yes = input$save\n        , excel = input$save_excel\n        )\n  \n  return( p )\n  \n})\n\nrenderUI({\n  \n  validate(\n    need(status$group_stat, 'Waiting for Group Stats')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$tree, 'Waiting for Decision Tree Data')\n  )\n  \n  d_clean       = rea_ana()\n  d_pca         = rea_pca()\n  data          = d_pca$data\n  boxcox        = d_clean$boxcox\n  categoricals  = d_clean$categoricals\n  all_variables = d_clean$all_variables\n  numericals    = d_clean$numericals\n\n  prin_comp = select(data, starts_with('PC', ignore.case = F)) %>%\n    names()\n  \n  inputPanel(\n  \n\n    selectInput(\"x_axis_pca\"\n                , label = \"select x_axis\"\n                , choices = prin_comp \n                , selected = prin_comp[2]\n                )\n\n    , selectInput(\"y_axis_pca\"\n                , label = \"select y_axis\"\n                , choices = prin_comp \n                , selected = prin_comp[1]\n                )\n    \n    , selectInput(\"group_pca\"\n                , label = \"select grouping variable\"\n                , choices = c(categoricals, 'None')\n                , selected = input$default_group\n                )\n    \n  )\n  \n})\n\n\n```\n\n\n### Plot Variance Explained\n\n\n```{r var_expl}\n\n# variance explained\n\nrenderPlot({\n  \n  validate(\n    need(status$group_stat, 'Waiting for Group Stats')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$tree, 'Waiting for Decision Tree Data')\n  )\n\n  pca = rea_pca()$pca\n  \n  vae = tibble( value = pca$sdev\n                , pca_n = str_c('pca', 1:length(pca$sdev))\n            ) \n\n  p =   ggplot(pca$contrib_abs_perc_reduced) +\n    geom_bar(aes(x = fct_reorder(var, value, sum, .desc = T )\n                 , y = value, fill = key)\n             , stat = 'identity'\n             , position='stack') +\n    scale_fill_brewer(palette = 'Paired') \n\n  name = stringr::str_c( input$sql_or_lib,'_variance_explained_')%>%\n    stringr::str_c( input$group_pca ) %>%\n    stringr::str_c('_boxcox', input$boxcox_pca) %>% \n    stringr::str_c('_scale',  input$scale_pca) %>% \n    stringr::str_c('_center', input$center_pca)  \n\n    save_plot(plot = p\n          , path = input$path\n          , name = name\n          , yes = input$save\n          , excel = input$save_excel\n          )\n\n  return(p)\n\n})\n\n\n```\n\n## Correlation\n\n```{r corr, eval = T}\n\nrea_corr = reactive({\n  \n  validate(\n    need(status$group_stat, 'Waiting for Group Stats')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$tree, 'Waiting for Decision Tree Data')\n    , need(status$pca, 'Waiting for Principle Component Analysis')\n  )\n  \n  #status$corr = NULL\n  \n  withProgress(message = 'Calculating Correlation matrix'\n               ,{\n  \n    d_clean       = rea_ana()\n    data          = d_clean$data\n    boxcox        = d_clean$boxcox\n    categoricals  = d_clean$categoricals\n    all_variables = d_clean$all_variables\n    numericals    = d_clean$numericals\n    \n    if(is_empty(boxcox)) return()\n    \n    corr = round( cor(data[, boxcox]), 1)\n    \n    p_val_corr = ggcorrplot::cor_pmat( data[, boxcox] )\n\n  })\n  \n  status$corr = T\n  \n  return( list(corr = corr,\n               p_val_corr = p_val_corr) )\n  \n})\n\nrenderPlot(width = 1024, height = 1024, {\n  \n  validate(\n    need(status$group_stat, 'Waiting for Group Stats')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$tree, 'Waiting for Decision Tree Data')\n    , need(status$pca, 'Waiting for Principle Component Analysis')\n  )\n  \n  corr = rea_corr()$corr\n  p_val_corr = rea_corr()$p_val_corr\n  \n  p = ggcorrplot::ggcorrplot( corr\n                              ,hc.order = TRUE\n                              , type = \"lower\"\n                              , lab = TRUE\n                              , p.mat = p_val_corr\n                              )\n  \n  name = stringr::str_c( input$sql_or_lib,'_correlation')\n\n  save_plot(plot = p\n        , path = input$path\n        , name = name\n        , yes = input$save\n        , excel = F\n        )\n  \n  return(p)\n    \n})\n```\n\n# Data Visualisation\n\n## Tabplot\n\n```{r tabplot, echo=FALSE, eval = T }\n\n\npreselect = c('all'\n              ,'none'\n              ,'categoricals'\n              ,'numericals'\n              ,'top_10_importance'\n              ,'boxcox'\n              ,'none_boxcox'\n              ,'pc1+pc2'\n              ,'pc1+pc2 contrib >2.5%'\n              ,'correlation'\n              ,'group_stat_P<0.001'\n              ,'2fac_2num'\n              )\n\nrenderUI({\n  \n  validate(\n    need(status$corr, 'Waiting for Correlation Data')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$pca, 'Waiting for Principle Component Data')\n  )\n  \n  d_clean       = rea_ana()\n  data          = d_clean$data\n  boxcox        = d_clean$boxcox\n  categoricals  = d_clean$categoricals\n  all_variables = d_clean$all_variables\n  numericals    = d_clean$numericals\n  \n  inputPanel(\n  \n     \n      sliderInput('n_breaks_tab'\n                  , label = \"Number of bins:\"\n                  , min = 1\n                  , max = 500\n                  , step = 1\n                  , value = 30)\n    \n    , selectInput(\"sort_col_tab\"\n                  , label = \"Sort_by\"\n                  , choices = names(data) \n                  , selected = numericals[1])\n    \n    , checkboxInput('decreasing_tab'\n                    , label = 'decreasing'\n                    , value = T)  \n    \n    , sliderInput('max_levels_tab'\n                  , label = \"Maximum number of levels for categorical variables\"\n                  , min = 3\n                  , max = 30\n                  , step = 1\n                  , value = 10)\n    \n    , selectInput(\"preselect\", label = \"preselect\"\n                  ,choices = preselect \n                  ,selected = 'top_10_importance')\n    \n    \n    , selectInput(\"preselect_correlation\", label = \"select_correlation\"\n                  ,choices = boxcox \n                  ,selected = boxcox[1])\n  \n    \n    \n  )\n\n})\nrenderPlot( {\n  \n  validate(\n    need(status$corr, 'Waiting for Correlation Data')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$pca, 'Waiting for Principle Component Data')\n  )\n  \n  withProgress( message = 'Rendering Tableplot'\n                , {\n  \n    d_clean       = rea_ana()\n    data          = d_clean$data\n    boxcox        = d_clean$boxcox\n    categoricals  = d_clean$categoricals\n    all_variables = d_clean$all_variables\n    numericals    = d_clean$numericals\n    \n    imp = rea_imp()\n    \n    p = tabplot::tableplot(data\n                  , select_string = input$select_vars_tab\n                  , sortCol       = input$sort_col_tab\n                  , decreasing    = input$decreasing_tab\n                  , nBins         = input$n_breaks_tab\n                  , max_levels    = input$max_levels_tab\n                  , scales = 'lin')\n    \n    index_str = stringr::str_c( which(all_variables %in% input$select_vars_tab)\n                                , collapse = '+'  )\n    \n    name = stringr::str_c( input$sql_or_lib,'_tabplot_')%>%\n    stringr::str_c('sort_', input$sort_col_tab, '_') %>% \n    stringr::str_c( index_str) \n  \n    save_plot(plot = p\n          , path = input$path\n          , name = name\n          , yes = input$save\n          , excel = F\n          )\n  })\n  \n  return(p)\n\n  })\n\n\nchk_bx_grp_ui = function(x,y, name, label) { renderUI({\n  \n  validate(\n    need(status$corr, 'Waiting for Correlation Data')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$pca, 'Waiting for Principle Component Data')\n  )\n  \n  d_clean       = rea_ana()\n  data          = d_clean$data\n  boxcox        = d_clean$boxcox\n  categoricals  = d_clean$categoricals\n  all_variables = d_clean$all_variables\n  numericals    = d_clean$numericals\n  \n  imp        = rea_imp()\n  p_val_corr = rea_corr()$p_val_corr\n  pca        = rea_pca()$pca\n\n  if(input[[x]] == 'all')               preselect = names(data)\n  if(input[[x]] == 'none')              preselect = NULL\n  if(input[[x]] == 'top_10_importance') preselect = imp$variable[1:10]\n  if(input[[x]] == 'boxcox')            preselect = boxcox\n  if(input[[x]] == 'none_boxcox')       preselect = names(data)[!names(data) %in% boxcox]\n  if(input[[x]] == 'numericals')        preselect = numericals\n  if(input[[x]] == 'categoricals')      preselect = categoricals\n  \n  if(input[[x]] == 'group_stat_P<0.001') {\n    \n    sig = rea_group_stats()$sig\n    \n    #remove boxcox that are also in numericals\n    sig_boxcox = sig$sig_boxcox %>%\n      stringr::str_extract('^[A-Za-z]*') %>%\n      .[!. %in% sig$sig_num] %>%\n      stringr::str_c('_boxcox')\n    \n    preselect = stringr::str_c( c(sig$sig_num, sig_boxcox, sig$sig_chi ) )\n  }\n  \n  if(input[[x]] == 'correlation') {\n    \n    correlating = p_val_corr %>%\n      as_tibble() %>%\n      mutate( vars = names(.) ) %>%\n      select( filter_var = one_of(input[[y]]), vars) %>%\n      filter( filter_var <= 0.05  ) %>%\n      select( vars )\n\n\n    preselect = correlating$vars\n  }\n  \n  if( startsWith( input[[x]], 'pc1+pc2')) {\n    \n    if(endsWith( input[[x]], '>2.5%')){\n      \n      pca_1_2 = pca$contrib_abs_perc_reduced %>%\n        filter(var %in% c('PC1', 'PC2') )\n      \n      preselect = pca_1_2$key\n      \n    }else {\n      \n      pca_1_2 = pca$contrib_abs_perc %>%\n        filter(var %in% c('PC1', 'PC2') )\n      \n      preselect = pca_1_2$key\n    \n    }\n    \n  }\n\n  \n  if(input[[x]] == '2fac_2num')  {\n    preselect = c(numericals[1], categoricals[1]\n                  ,numericals[2], categoricals[2]\n                  ,numericals[3], categoricals[3]\n                  ,numericals[4], categoricals[4]\n                  )[1:4]\n  }\n  \n\n  checkboxGroupInput( name\n                    , label = label\n                    , choices = names(data)\n                    , selected = preselect\n                    , inline = F )\n })\n}\n\nchk_bx_grp_ui('preselect', 'preselect_correlation', name = 'select_vars_tab', label = 'Select Variables')\n\n```\n\n## ggduo\n\n```{r ggduo, eval = T }\n\nrenderUI({\n  \n  validate(\n    need(status$corr, 'Waiting for Correlation Data')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$pca, 'Waiting for Principle Component Data')\n  )\n  \n  d_clean       = rea_ana()\n  data          = d_clean$data\n  boxcox        = d_clean$boxcox\n  categoricals  = d_clean$categoricals\n  all_variables = d_clean$all_variables\n  numericals    = d_clean$numericals\n  \n  inputPanel(\n    \n    selectInput(\"preselect_duo_col\"\n                , label = \"Preselect Column\"\n              ,choices = preselect \n              ,selected = '2fac_2num')\n\n    , selectInput(\"preselect_duo_row\"\n                , label = \"Preselect Row\"\n              ,choices = preselect \n              ,selected = '2fac_2num')\n  \n\n  )\n})\n\nrenderUI({\n  \n  d_clean       = rea_ana()\n  data          = d_clean$data\n  boxcox        = d_clean$boxcox\n  categoricals  = d_clean$categoricals\n  all_variables = d_clean$all_variables\n  numericals    = d_clean$numericals\n\n  inputPanel(\n  \n   selectInput(\"preselect_corr_duo_col\"\n                , label = \"Select Correlation Column\"\n                ,choices = boxcox \n                ,selected = boxcox[1])\n  \n  , selectInput(\"preselect_corr_duo_row\"\n                , label = \"Select Correlation Row\"\n                ,choices = boxcox \n                ,selected = boxcox[1])\n\n  )\n  \n})\n\nrea_duo = eventReactive(input$but_duo\n                        , {\n                          \n  validate(\n    need(status$corr, 'Waiting for Correlation Data')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$pca, 'Waiting for Principle Component Data')\n  )\n  \n  \n  return( list(col    = input$select_vars_duo_col\n               ,row   = input$select_vars_duo_row\n               ,group = input$group_duo\n               ,corr  = input$corr_duo) )\n                          \n} )\n\n\n  renderPlot(   height = function(){\n    \n                  input$group_vis_plot_height_ggduo\n                  \n                },   expr ={\n  \n  withProgress( message = 'Rendering GGduo matrix plot'\n                , {\n  \n    d_clean       = rea_ana()\n    data          = d_clean$data\n    boxcox        = d_clean$boxcox\n    categoricals  = d_clean$categoricals\n    all_variables = d_clean$all_variables\n    numericals    = d_clean$numericals\n    \n    ret   = rea_duo()\n    col   = ret$col\n    row   = ret$row\n    group = ret$group\n    corr  = ret$corr\n    \n    if(group == 'None') group = NULL\n  \n    lm_with_cor <- function(data, mapping, ..., method = \"pearson\") {\n      x <- data[[deparse(mapping$x)]]\n      y <- data[[deparse(mapping$y)]]\n      cor <- cor(x, y, method = method)\n      GGally::ggally_smooth_lm(data, mapping, ...) +\n        ggplot2::geom_label(\n          data = data.frame(\n            x = min(x, na.rm = TRUE),\n            y = max(y, na.rm = TRUE),\n            lab = round(cor, digits = 3)\n          ),\n          mapping = ggplot2::aes(x = x, y = y, label = lab, color = NULL),\n          hjust = 0, vjust = 1,\n          size = 5, fontface = \"bold\"\n        )\n    }\n  \n    \n    if(corr == T)  {  \n      p =GGally::ggduo(\n        data, col, row,\n        mapping = aes_string(color = group),\n        types = list(continuous = GGally::wrap(lm_with_cor, alpha = 0.25)),\n        showStrips = FALSE\n      ) +\n        theme(legend.position = \"bottom\")\n    }\n    \n    else{\n      p = GGally::ggduo(\n        data, col, row,\n        mapping = aes_string(color = group),\n        #types = list(continuous = wrap(lm_with_cor, alpha = 0.25)),\n        showStrips = FALSE\n      ) +\n        theme(legend.position = \"bottom\")\n    }\n  \n    index_str_row = stringr::str_c( which(all_variables %in% row)\n                                , collapse = '+'  )\n    \n    index_str_col = stringr::str_c( which(all_variables %in% col)\n                                , collapse = '+'  )\n    \n    name = stringr::str_c( input$sql_or_lib,'_ggduo')%>%\n    stringr::str_c('_sort', input$sort_col_tab ) %>% \n    stringr::str_c( '_col', index_str_col) %>%\n    stringr::str_c( '_row', index_str_row) \n  \n    save_plot(plot = p\n          , path = input$path\n          , name = name\n          , yes = input$save\n          , excel = F\n          )\n  })\n  \n  return(p)\n})\n\nrenderUI({\n  \n  d_clean       = rea_ana()\n  data          = d_clean$data\n  boxcox        = d_clean$boxcox\n  categoricals  = d_clean$categoricals\n  all_variables = d_clean$all_variables\n  numericals    = d_clean$numericals\n\n\n  inputPanel(\n    \n    selectInput(\"group_duo\"\n                , label = \"select grouping variable\"\n                , choices = c(categoricals, 'None')\n                , selected = input$default_group \n                )\n    \n    , checkboxInput('corr_duo'\n                    , label = 'show corr coef'\n                    , value = T)  \n  \n    \n    , actionButton('but_duo', 'Render Plot')\n    \n    , sliderInput('group_vis_plot_height_ggduo'\n                   , 'Adjust Plot Height GGduo'\n                   , min = 100\n                   , max = 2000\n                   , value = 250)\n    \n  )\n  \n  \n\n})\n\n# chk_bx_grp_ui has its own gui rendering function\n\nsplitLayout(\n\n\n   chk_bx_grp_ui('preselect_duo_col', 'preselect_corr_duo_col'\n                   , name = 'select_vars_duo_col'\n                   , label = 'Select Variables Column')\n\n\n   , chk_bx_grp_ui('preselect_duo_row', 'preselect_corr_duo_row'\n                   , name = 'select_vars_duo_row'\n                   , label = 'Select Variables Row')\n\n\n )\n\n```\n\n## Histograms\n\n### Histogram A\n\n```{r histo general, echo=FALSE, eval = T }\n\ninput_panel_histo = function(suffix, default_type = 'bar') {\n  \n  renderUI({\n    \n    validate(\n      need(status$corr, 'Waiting for Correlation Data')\n      , need(status$imp, 'Waiting for Predictive Capacity Data')\n      , need(status$pca, 'Waiting for Principle Component Data')\n    )\n  \n    d_clean       = rea_ana()\n    data          = d_clean$data\n    boxcox        = d_clean$boxcox\n    categoricals  = d_clean$categoricals\n    all_variables = d_clean$all_variables\n    numericals    = d_clean$numericals\n    \n    \n    \n    inputPanel(\n    \n      selectInput(str_c(\"n_breaks\", suffix)\n                  , label = \"Number of bins:\"\n                  , choices = c(10, 20, 30, 50, 75, 100, 150, 200, 300, 500, 750, 1000)\n                  , selected = 30\n                  )\n      \n      , selectInput(str_c(\"variable\", suffix)\n                    , label = \"Select variable\"\n                    , choices = names(data) \n                    , selected = numericals[1]\n                    )\n      \n      , selectInput(str_c( \"group\", suffix)\n                    , label = \"Select grouping variable\"\n                    , choices = c(categoricals , 'None')\n                    , selected = input$default_group\n                    )\n      \n      , selectInput(str_c(\"graph_type\", suffix)\n                    , label = \"Graph Type\"\n                    , choices = c('bar', 'line', 'violin') \n                    , selected = default_type)\n      \n      , selectInput(str_c(\"y_axis\", suffix)\n                    , label = \"Y-Axis\"\n                    , choices = c('density', 'counts') \n                    , selected = 'density')\n      \n      , checkboxInput(str_c( 'auto_range', suffix )\n                      , label = 'use automatic range'\n                      , value = T)  \n      \n      , textInput(str_c('x_min', suffix)\n                  , label = 'X-min'\n                  , value = '0')\n      \n      , textInput(str_c('x_max', suffix)\n                  , label = 'X-max'\n                  , value = '1000')\n  \n    )\n  \n  })\n}\n\nrenderPlot_histo = function( suffix ){\n  \n  \n  renderPlot({\n    \n  validate(\n    need(status$corr, 'Waiting for Correlation Data')\n    , need(status$imp, 'Waiting for Predictive Capacity Data')\n    , need(status$pca, 'Waiting for Principle Component Data')\n  )\n    \n    withProgress( message = 'Rendering Histogram'\n                  , {\n    \n      d_clean       = rea_ana()\n      data          = d_clean$data\n      boxcox        = d_clean$boxcox\n      categoricals  = d_clean$categoricals\n      all_variables = d_clean$all_variables\n      numericals    = d_clean$numericals\n  \n      \n      # get input\n      \n      n_breaks   = input[[ str_c(\"n_breaks\"   , suffix) ]]\n      variable   = input[[ str_c(\"variable\"   , suffix) ]]\n      group      = input[[ str_c( \"group\"     , suffix) ]]\n      graph_type = input[[ str_c(\"graph_type\" , suffix) ]]\n      y_axis     = input[[ str_c(\"y_axis\"     , suffix) ]]\n      auto_range = input[[ str_c( 'auto_range', suffix) ]]\n      x_min      = input[[ str_c('x_min'      , suffix) ]]\n      x_max      = input[[ str_c('x_max'      , suffix) ]]\n      \n  \n      #y-axis\n      if(y_axis == 'density') {\n        y_axis = '..density..'\n      }\n      else{\n        y_axis = '..count..'\n      }\n      \n      #group\n      \n      if(group == 'None') group = NULL \n    \n      # numericals ----------------------------------------------------------------------------\n      \n      numericals = c(numericals, boxcox)\n      \n      #geom_freqpoly \n      if(variable %in% numericals & graph_type == 'line'){\n        \n        p = data %>%\n        ggplot() +\n          geom_freqpoly( aes_string(x = variable, y = y_axis, color = group)\n                         , bins =  as.numeric(n_breaks))\n      }\n      \n  \n       #geom_histo \n      if(variable %in% numericals & graph_type == 'bar' ){\n      \n          \n        p = data %>%\n        ggplot() +\n          geom_histogram( aes_string(x = variable, y = y_axis, fill = group)\n                         , bins =  as.numeric(n_breaks), alpha = 0.6\n                         , position = 'identity')\n      }\n      \n      #geom_violin \n      if(variable %in% numericals & graph_type == 'violin'){\n        \n        medians = data %>%\n          group_by_(as.symbol(group)) %>%\n          select( one_of(numericals ) ) %>%\n          summarise_all(  median )\n                     \n        \n        p = data %>%\n        ggplot() +\n          geom_violin( aes_string(x = group\n                                  , y = variable\n                                  , fill = group)\n                        ) +\n          geom_crossbar( data = medians,\n                         mapping = aes_string(x = group\n                                    , y = variable\n                                    , ymin = variable\n                                    , ymax = variable) )\n      }\n      \n      \n      # add x range\n      \n      if(variable %in% numericals & auto_range == F & !graph_type == 'violin'){\n        \n        p = p +\n          xlim( c( as.numeric(x_min), as.numeric(x_max)) )\n      }\n     \n      # add y range\n      \n      if(variable %in% numericals & auto_range == F & graph_type == 'violin'){\n        \n        p = p +\n          ylim( c( as.numeric(x_min), as.numeric(x_max)) )\n      }\n      \n    \n      # categoricals ----------------------------------------------------------------------------\n      \n      #geom_bar\n      if(variable %in% categoricals ){\n        \n        if(y_axis == '..density..')   y_axis = '..prop..'\n    \n        p = data %>%\n        ggplot() +\n          geom_bar( aes_string(x = variable, y = y_axis, fill = group, group = group)\n                         , position = 'dodge') +\n          ggplot2::theme( axis.text.x = ggplot2::element_text(angle = 90) )\n        \n        \n        }\n    \n      y_axis_str = stringr::str_extract_all(y_axis\n                                            , '[A-Za-z]') %>%\n        unlist()%>%\n        stringr::str_c(collapse = '')\n      \n      name = stringr::str_c( input$sql_or_lib, '_')%>%\n      stringr::str_c(suffix ) %>% \n      stringr::str_c('_', graph_type ) %>%\n      stringr::str_c('_', y_axis_str)  %>%\n      stringr::str_c( '_group', group) %>%\n      stringr::str_c( '_var', variable) %>%\n      stringr::str_c( '_', n_breaks)\n        \n      save_plot(plot = p\n            , path = input$path\n            , name = name\n            , yes = input$save\n            , excel = input$save_excel\n            )\n    })\n    \n    return(p)\n    \n    })\n}\n\n\n\n```\n\n```{r histo_a, eval = T}\n\n\n\ninput_panel_histo('histo_a', default_type = 'bar')\n\nrenderPlot_histo('histo_a')\n\n```\n\n\n\n### Histogram B\n\n```{r histo_b, eval = T}\n\ninput_panel_histo('histo_b', default_type = 'line')\n\nrenderPlot_histo('histo_b')\n\n```\n\n### Histogram C\n\n```{r histo_c, eval = T}\n\ninput_panel_histo('histo_c', default_type = 'violin')\n\nrenderPlot_histo('histo_c')\n\n```\n\n### Histogram D\n\n```{r histo_d, eval = T}\n\ninput_panel_histo('histo_d')\n\nrenderPlot_histo('histo_d')\n\n```\n\n### Histogram E\n\n```{r histo_e, eval = T}\n\ninput_panel_histo('histo_e')\n\nrenderPlot_histo('histo_e')\n\n```\n\n### Histogram F\n\n```{r histo_f, eval = T}\n\ninput_panel_histo('histo_f')\n\nrenderPlot_histo('histo_f')\n\n```\n\n# Save\n\n```{r}\n\nmod_save(input, rea_ana)\n\n```\n\n",
    "created" : 1505970473097.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2093269380",
    "id" : "A1D20220",
    "lastKnownWriteTime" : 1505971085,
    "last_content_update" : 1505971085066,
    "path" : "C:/Users/erbla/OneDrive/R/multiview/multiview_v08.Rmd",
    "project_path" : "multiview_v08.Rmd",
    "properties" : {
        "docOutlineSize" : "135.94300382243642",
        "docOutlineVisible" : "1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}